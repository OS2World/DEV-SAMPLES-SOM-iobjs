//**********************************************************************
// File name: client.c
//
//    Implementation file for client application
//
// Functions:
//    See client.h for a list of member functions.
//
// Copyright (c) 1994 Microsoft Corporation. All rights reserved.
//**********************************************************************
#include <windows.h>   
#include <ole2.h>      
#include <ole2ver.h>

#include <initguid.h>
#include "..\guids.h"

#include "resource.h"
#define COBJMACROS  // get cool C macros
#include "..\idl\pd.h"  // generated by MIDL compiler
#include "client.h"   

//**********************************************************************
// WinMain
//
// Purpose: Program entry point
//
// Parameters:
//      HANDLE hInstance        - Instance handle for this instance
//      HANDLE hPrevInstance    - Instance handle for the last instance
//      LPSTR lpCmdLine         - Pointer to the command line
//      int nCmdShow            - Window State
//
// Return Value: msg.wParam
//********************************************************************
int APIENTRY WinMain(HINSTANCE hInstance,
					 HINSTANCE hPrevInstance,
					 LPSTR lpCmdLine,
					 int nCmdShow)
{

	MSG msg;

	if (!hPrevInstance) 
	{     
	      if (!InitApplication(hInstance))
			return (FALSE);     
	}

	if (!InitInstance(hInstance, nCmdShow)) 
	      return (FALSE);

       
	while (GetMessage(&msg, NULL, 0,0))    
	{
			TranslateMessage(&msg);
			DispatchMessage(&msg); 
	}


	if (fOleInitialized)
	  OleUninitialize();

	return (msg.wParam); // Returns the value from PostQuitMessage

	lpCmdLine; // This will prevent 'unused formal parameter' warnings
}


//**********************************************************************
// InitApplication
//
// Purpose: Initializes window data and registers window class
//
// Parameters:
//      HANDLE hInstance        - Instance handle for this instance
//
// Return Value: TRUE on successful initialization, FALSE otherwise
//********************************************************************
BOOL InitApplication(HINSTANCE hInstance)
{
	WNDCLASS  wc;
	
	wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
	wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure
	wc.cbClsExtra    = 0;                      // No per-class extra data.
	wc.cbWndExtra    = 0;                      // No per-window extra data.
	wc.hInstance     = hInstance;              // Owner of this class
	wc.hIcon         = LoadIcon (hInstance, szAppName); // Icon name from .RC
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);// Cursor
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color
	wc.lpszMenuName  = szAppName;              // Menu name from .RC
	wc.lpszClassName = szAppName;              // Name to register as

	// Register the window class and return success/failure code.
	return (RegisterClass(&wc));
}

//**********************************************************************
// InitInstance
//
// Purpose: Saves instance handle, creates main window, and initializes
//          OLE.
//
// Parameters:
//      HANDLE hInstance        - Instance handle for this instance
//
// Return Value: TRUE on successful initialization, FALSE otherwise
//********************************************************************
BOOL InitInstance(HINSTANCE       hInstance,
				  int             nCmdShow)
{
	HWND            hWnd; 
	DWORD           dwVer;

	hInst = hInstance; 

	dwVer = OleBuildVersion();

	// check to see if we are compatible with this version of the libraries
	if (HIWORD(dwVer) != rmm || LOWORD(dwVer) < rup)
	{
	    OutputDebugString(TEXT("*** WARNING:  Not compatible with current libs ***\r\n"));
		return FALSE;
	}

	// initialize the libraries
	if (NOERROR == OleInitialize(NULL))
		fOleInitialized = TRUE;

	hWnd = CreateWindow(
		szAppName,           // See RegisterClass() call.
		szTitle,             // Text for window title bar.
		WS_OVERLAPPEDWINDOW,// Window style.
		CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, // Use default positioning
		NULL,                // Overlapped windows have no parent.
		NULL,                // Use the window class menu.
		hInstance,           // This instance owns this window.
		NULL                 // We don't use any data in our WM_CREATE
	);

	// If window could not be created, return "failure"
	if (!hWnd) 
		return (FALSE);
	

	// Make the window visible; update its client area; and return "success"
	ShowWindow(hWnd, nCmdShow); // Show the window
	UpdateWindow(hWnd);         // Sends WM_PAINT message

	return (TRUE);              // We succeeded...

}

//**********************************************************************
// WndProc
//
// Purpose: Processes messages
//
// Parameters:
//      HWND hWnd  - Window handle
//      UINT message - type of message
//      WPARAM uParam - additional information
//      LPARAM lParam - additional information
//********************************************************************
LRESULT CALLBACK WndProc(HWND hWnd,
						 UINT message,
						 WPARAM uParam,  
						 LPARAM lParam)  
{

	switch (message) 
	{

		case WM_INITMENUPOPUP:  // initialize menu items
		{
				  
			if ((TRUE == (BOOL)HIWORD(lParam)) ||(0 != LOWORD(lParam)))  // not the File menu
			    return TRUE;

			else
			{
			    HMENU hMenuFile = (HMENU)uParam;

				// We've got the File menu...
				// Enable the Connect item if we're not connected
				EnableMenuItem(hMenuFile, 
						       ID_CONNECT, 
						       MF_BYCOMMAND | (fConnected ? MF_GRAYED : MF_ENABLED));

				// Enable the lookup items if we are connected
				EnableMenuItem(hMenuFile, 
						       ID_LOOKUPBYNAME,
						       MF_BYCOMMAND | (fConnected ? MF_ENABLED : MF_GRAYED));
				
				EnableMenuItem(hMenuFile, 
						       ID_LOOKUPBYNUM, 
						       MF_BYCOMMAND |(fConnected ? MF_ENABLED : MF_GRAYED));
				return FALSE;
			}
		}       
													 
		case WM_COMMAND:  // message: command from application menu
				    
		switch (LOWORD(uParam)) 
		{
			case ID_EXIT:  // exit application
			    DestroyWindow (hWnd);
			    break;

			case ID_CONNECT:  // Connect to the phone book server
			{
				HRESULT     hRes;

		// Create an instance of the phone book app.
		// Normally, we would query the registration database
		// for the CLSID; however, for the sake of simplicity
		// for this sample, we've hard-coded it.
		hRes = CoCreateInstance(&CLSID_PHONEBOOK,
					NULL,
					CLSCTX_SERVER,
					&IID_ILookup,
					&pLookup);

				if (SUCCEEDED(hRes))
				{
					MessageBox(hWnd, TEXT("Connected"), TEXT("CoCreateInstance"), MB_OK);
					fConnected = TRUE;  // we've got a pLookup pointer to use
				}
				else
					MessageBox(hWnd, TEXT("Failure"), TEXT("CoCreateInstance"), MB_OK);
			}
			break;

			case ID_LOOKUPBYNAME:  
			case ID_LOOKUPBYNUM:
			{
				TCHAR                   *ptszFound;           // returned string from method call
				TCHAR                   ptszInput[MAXBUFF];  // string we pass to ILookupByName/Number
				TCHAR           ptszResBuff[MAXBUFF * 3];  // results string
				BOOL            fByName = (ID_LOOKUPBYNAME == LOWORD(uParam));
				BOOL            fOK; 
				HRESULT                 hRes;
				FARPROC                 lpProcFind;
				FINDDLGINFO     fdInfo;
	
				// initialize structre to pass to DialogBoxParam
				fdInfo.ptszNameNum = ptszInput;
				fdInfo.uDlgType = LOWORD(uParam);

				// Get input  from user
				lpProcFind = MakeProcInstance((FARPROC)Find, hInst);
				fOK = DialogBoxParam(hInst, TEXT("FindDialog"), hWnd,  (DLGPROC)lpProcFind, (LPARAM)&fdInfo); 
				FreeProcInstance(lpProcFind);

				if (!fOK)  // user cancelled dialog
					break;

				// Call ILookupByName or ILookupByNumber
				// ILookup_<method> are C macros generated by the MIDL compiler 
				// They are not necessary and are just provided for convenience - 
				// they expand to pLookup->lpVtbl-><method>(pLookup, <args>)
				if (fByName)
					hRes = ILookup_LookupByName(pLookup, ptszInput, &ptszFound);

				else
					hRes = ILookup_LookupByNumber(pLookup, ptszInput, &ptszFound);

	    
				if (FAILED(hRes))  // Call Failed
				{
					MessageBox(hWnd, TEXT("Failure"), fByName ? TEXT("LookupByName"):TEXT("LookupByNumber"), MB_OK);
					break;
				}

				// Call succeeded, but string user entered wasn't in database
				if (S_FALSE == hRes)  // entry not found in database
					ptszFound = ptszNotFound;
				
				// Format output
				wsprintf(ptszResBuff, 
						 TEXT("Name: %s\r\nPhone Number: %s"),
						 (fByName ? ptszInput : ptszFound),
						 (fByName ? ptszFound : ptszInput));

				// Display results to user
				MessageBox(hWnd, ptszResBuff, TEXT("Results"), MB_OK);

				if (ptszFound == ptszNotFound)
				{
					ptszFound = NULL;
					break;
				}

				// Free the memory passed to us.
				if (NULL == pMalloc)
				{
					hRes = CoGetMalloc(MEMCTX_TASK, &pMalloc);
					if (FAILED(hRes))
						break;
				}

				pMalloc->lpVtbl->Free(pMalloc, ptszFound);
			}
			break;

		
			default:
				return (DefWindowProc(hWnd, message, uParam, lParam));
		    }
		    break;

		case WM_DESTROY:  // message: window being destroyed
			if (pMalloc)
				pMalloc->lpVtbl->Release(pMalloc);  // release the IMalloc pointer
			if (pLookup)
				ILookup_Release(pLookup);  // release our pointer to the phonebook object
			PostQuitMessage(0);
			break;

		default:          // Passes it on if unproccessed
			return (DefWindowProc(hWnd, message, uParam, lParam));
	}
	return (0);
}

LRESULT CALLBACK Find(
		HWND hDlg,           // window handle of the dialog box
		UINT message,        // type of message
		WPARAM uParam,       // message-specific information
		LPARAM lParam)
{

	switch (message) 
	{
		case WM_INITDIALOG:
		{
			LPFINDDLGINFO pfdInfo = (LPFINDDLGINFO)lParam;

			SetProp(hDlg, TEXT("RetString"), pfdInfo->ptszNameNum);

			if (ID_LOOKUPBYNUM == pfdInfo->uDlgType)
			{
				SetWindowText(hDlg, ptszFindNum);
				SetDlgItemText(hDlg, IDC_ENTER, ptszEnter);
			}

			SetFocus(GetDlgItem(hDlg, IDC_NAMENUM));  
			SendDlgItemMessage(hDlg, IDC_NAMENUM, EM_LIMITTEXT, MAXBUFF - 1, 0);
			return (FALSE);
		}

		case WM_COMMAND:                      
			if (LOWORD(uParam) == IDOK)
			{
				LPTSTR pstrRet;

				pstrRet = (LPTSTR)GetProp(hDlg, TEXT("RetString"));
				GetDlgItemText(hDlg, IDC_NAMENUM, pstrRet, MAXBUFF);
				EndDialog(hDlg, TRUE);
				return (TRUE);
			}
			if (LOWORD(uParam) == IDCANCEL)
				EndDialog(hDlg, FALSE);        
				return (TRUE);
		
			break;
	}
	return (FALSE); // Didn't process the message

	lParam; // This will prevent 'unused formal parameter' warnings
}




